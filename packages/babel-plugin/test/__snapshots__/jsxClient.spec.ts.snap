// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`jsx transform > should work with CSS Variables transform to inline style 1`] = `
"import { template as _template$, createComponent as _createComponent$ } from "est";
const _tmpl$ = _template$("<div style=\\"--color: red;\\">Hello, World!");
const element = (() => {
  const _el = _tmpl$();
  return _el;
})();"
`;

exports[`jsx transform > should work with bind api 1`] = `
"import { template as _template$, createComponent as _createComponent$, mapNodes as _mapNodes$, setAttr as _setAttr$, insert as _insert$ } from "est";
const _tmpl$ = _template$("<div><p>Paragraph 1</p><p>Paragraph 2</p>");
const value = 1;
(() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [2]);
  _setAttr$(_nodes[0], "value", value);
  _setAttr$(_nodes[0], "updateValue", _value => value = _value);
  return _el;
})();"
`;

exports[`jsx transform > should work with comment in JSX 1`] = `
"import { template as _template$, createComponent as _createComponent$, mapNodes as _mapNodes$, setAttr as _setAttr$, insert as _insert$ } from "est";
const _tmpl$ = _template$("<div><p>Paragraph 1</p><p>Paragraph 2</p>");
const value = 1;
(() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [3]);
  _setAttr$(_nodes[0], "value", value);
  _setAttr$(_nodes[0], "updateValue", _value => value = _value);
  return _el;
})();"
`;

exports[`jsx transform > should work with concurrent mode 1`] = `
"import { template as _template$, createComponent as _createComponent$, mapNodes as _mapNodes$, insert as _insert$ } from "est";
const _tmpl$ = _template$("<div data-concurrent>"),
  _tmpl$2 = _template$("<div>Concurrent Mode Content");
const ConcurrentMode = ({
  children
}) => (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1]);
  _insert$(_nodes[0], () => children);
  return _el;
})();
const element = _createComponent$(ConcurrentMode, {
  "children": [(() => {
    const _el2 = _tmpl$2();
    return _el2;
  })()]
});"
`;

exports[`jsx transform > should work with concurrent mode and suspense 1`] = `
"import { template as _template$, createComponent as _createComponent$ } from "est";
const _tmpl$ = _template$("<div>Loading..."),
  _tmpl$2 = _template$("<div>Concurrent Mode Suspended Content");
const element = _createComponent$(ConcurrentMode, {
  "children": [_createComponent$(Suspense, {
    "fallback": (() => {
      const _el = _tmpl$();
      return _el;
    })(),
    "children": [(() => {
      const _el2 = _tmpl$2();
      return _el2;
    })()]
  })]
});"
`;

exports[`jsx transform > should work with conditional rendering 1`] = `
"import { template as _template$, createComponent as _createComponent$, mapNodes as _mapNodes$, insert as _insert$ } from "est";
const _tmpl$ = _template$("<div><!>"),
  _tmpl$2 = _template$("<p>Visible Content"),
  _tmpl$3 = _template$("<span>True"),
  _tmpl$4 = _template$("<span>False");
const isVisible = true;
const element = (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1, 2]);
  _insert$(_nodes[0], () => isVisible && (() => {
    const _el2 = _tmpl$2();
    return _el2;
  })(), _nodes[1]);
  _insert$(_nodes[0], () => isVisible ? (() => {
    const _el3 = _tmpl$3();
    return _el3;
  })() : (() => {
    const _el4 = _tmpl$4();
    return _el4;
  })());
  return _el;
})();"
`;

exports[`jsx transform > should work with context 1`] = `
"import { template as _template$, createComponent as _createComponent$ } from "est";
const _tmpl$ = _template$("<div>Themed Content");
const ThemeContext = {
  Provider: ({
    value,
    children
  }) => children
};
const element = _createComponent$(ThemeContext.Provider, {
  "value": "dark",
  "children": [(() => {
    const _el = _tmpl$();
    return _el;
  })()]
});"
`;

exports[`jsx transform > should work with context and memo combination 1`] = `
"import { template as _template$, createComponent as _createComponent$, mapNodes as _mapNodes$, setAttr as _setAttr$, insert as _insert$ } from "est";
const _tmpl$ = _template$("<div>Memo Content");
const ThemeContext = {
  Provider: ({
    value,
    children
  }) => children
};
const MemoComponent = ({
  theme
}) => (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1]);
  _setAttr$(_nodes[0], "data-theme", theme);
  return _el;
})();
MemoComponent._memo = true;
const element = _createComponent$(ThemeContext.Provider, {
  "value": "dark",
  "children": [_createComponent$(MemoComponent, {
    "theme": "dark"
  })]
});"
`;

exports[`jsx transform > should work with context providers 1`] = `
"import { template as _template$, createComponent as _createComponent$ } from "est";
const _tmpl$ = _template$("<div data-theme=\\"dark\\">Themed Content");
const ThemeContext = {
  Provider: ({
    value,
    children
  }) => children
};
const element = _createComponent$(ThemeContext.Provider, {
  "value": "dark",
  "children": [(() => {
    const _el = _tmpl$();
    return _el;
  })()]
});"
`;

exports[`jsx transform > should work with custom hooks in components 1`] = `
"import { template as _template$, createComponent as _createComponent$, mapNodes as _mapNodes$, setAttr as _setAttr$, insert as _insert$ } from "est";
const _tmpl$ = _template$("<div>Hook Content");
const useCustomHook = () => ({
  value: 'custom'
});
const Component = () => {
  const {
    value
  } = useCustomHook();
  return (() => {
    const _el = _tmpl$();
    const _nodes = _mapNodes$(_el, [1]);
    _setAttr$(_nodes[0], "data-hook", value);
    return _el;
  })();
};
const element = _createComponent$(Component, {});"
`;

exports[`jsx transform > should work with dynamic class names 1`] = `
"import { computed as _computed$, template as _template$, createComponent as _createComponent$, mapNodes as _mapNodes$, setClass as _setClass$, insert as _insert$ } from "est";
const _tmpl$ = _template$("<div>Dynamic Class");
const isActive = true;
const element = (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1]);
  _setClass$(_nodes[0], _computed$(() => isActive ? 'active' : ''));
  return _el;
})();"
`;

exports[`jsx transform > should work with dynamic imports 1`] = `
"import { template as _template$, createComponent as _createComponent$, mapNodes as _mapNodes$, insert as _insert$ } from "est";
const _tmpl$ = _template$("<div data-dynamic>");
const DynamicComponent = ({
  children
}) => (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1]);
  _insert$(_nodes[0], () => children);
  return _el;
})();
const element = _createComponent$(DynamicComponent, {
  "children": [import('./Component')]
});"
`;

exports[`jsx transform > should work with dynamic style transform to inline style 1`] = `
"import { template as _template$, createComponent as _createComponent$, mapNodes as _mapNodes$, setStyle as _setStyle$, insert as _insert$ } from "est";
const _tmpl$ = _template$("<div>Hello, World!");
const color = "red";
const style = {
  color,
  fontSize: '16px'
};
const element = (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1]);
  _setStyle$(_nodes[0], style);
  return _el;
})();"
`;

exports[`jsx transform > should work with dynamic styles 1`] = `
"import { template as _template$, createComponent as _createComponent$ } from "est";
const _tmpl$ = _template$("<div style=\\"color:undefined;fontSize:16px;\\">Dynamic Style");
const color = 'red';
const element = (() => {
  const _el = _tmpl$();
  return _el;
})();"
`;

exports[`jsx transform > should work with error boundaries 1`] = `
"import { template as _template$, createComponent as _createComponent$ } from "est";
const _tmpl$ = _template$("<div>Error occurred!"),
  _tmpl$2 = _template$("<div>Protected Content");
const ErrorBoundary = ({
  children
}) => {
  try {
    return children;
  } catch (error) {
    return (() => {
      const _el = _tmpl$();
      return _el;
    })();
  }
};
const element = _createComponent$(ErrorBoundary, {
  "children": [(() => {
    const _el2 = _tmpl$2();
    return _el2;
  })()]
});"
`;

exports[`jsx transform > should work with error boundaries 2`] = `
"import { template as _template$, createComponent as _createComponent$, mapNodes as _mapNodes$, insert as _insert$ } from "est";
const _tmpl$ = _template$("<div data-error-boundary><!>"),
  _tmpl$2 = _template$("<div>Error occurred!"),
  _tmpl$3 = _template$("<div>Protected Content");
const ErrorBoundary = ({
  children,
  fallback
}) => (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1, 2]);
  _insert$(_nodes[0], () => children, _nodes[1]);
  _insert$(_nodes[0], () => fallback);
  return _el;
})();
const element = _createComponent$(ErrorBoundary, {
  "fallback": (() => {
    const _el2 = _tmpl$2();
    return _el2;
  })(),
  "children": [(() => {
    const _el3 = _tmpl$3();
    return _el3;
  })()]
});"
`;

exports[`jsx transform > should work with event handlers 1`] = `
"import { template as _template$, createComponent as _createComponent$, mapNodes as _mapNodes$, addEventListener as _addEventListener$, insert as _insert$ } from "est";
const _tmpl$ = _template$("<button>Click me");
const handleClick = () => console.log('clicked');
const element = (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1]);
  _addEventListener$(_nodes[0], "click", handleClick);
  return _el;
})();"
`;

exports[`jsx transform > should work with forwardRef and memo 1`] = `
"import { template as _template$, createComponent as _createComponent$, mapNodes as _mapNodes$, setAttr as _setAttr$, insert as _insert$ } from "est";
const _tmpl$ = _template$("<div>Forward Ref Memo:");
const ForwardRefMemoComponent = React.memo(React.forwardRef((props, ref) => (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1]);
  _setAttr$(_nodes[0], "ref", ref);
  _insert$(_nodes[0], () => props.value);
  return _el;
})()));
const element = _createComponent$(ForwardRefMemoComponent, {
  "value": 42,
  "ref": React.createRef()
});"
`;

exports[`jsx transform > should work with forwardRef components 1`] = `
"import { template as _template$, createComponent as _createComponent$, mapNodes as _mapNodes$, setAttr as _setAttr$, insert as _insert$ } from "est";
const _tmpl$ = _template$("<div>");
const ForwardRefComponent = ({
  children
}, ref) => (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1]);
  _setAttr$(_nodes[0], "ref", ref);
  _insert$(_nodes[0], () => children);
  return _el;
})();
ForwardRefComponent._forward = true;
const element = _createComponent$(ForwardRefComponent, {
  "children": ["Forward Ref Content"]
});"
`;

exports[`jsx transform > should work with fragments and keys 1`] = `
"import { template as _template$, Fragment as _Fragment$ } from "est";
const _tmpl$ = _template$("<div key=\\"1\\">First</div><div key=\\"2\\">Second</div>");
const element = (() => {
  const _el = _tmpl$();
  return _el;
})();"
`;

exports[`jsx transform > should work with lazy components 1`] = `
"import { template as _template$, createComponent as _createComponent$, mapNodes as _mapNodes$, insert as _insert$ } from "est";
const _tmpl$ = _template$("<div data-lazy>");
const LazyComponent = ({
  children
}) => (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1]);
  _insert$(_nodes[0], () => children);
  return _el;
})();
LazyComponent._lazy = true;
const element = _createComponent$(LazyComponent, {
  "children": ["Lazy Content"]
});"
`;

exports[`jsx transform > should work with list rendering 1`] = `
"import { template as _template$, createComponent as _createComponent$, mapNodes as _mapNodes$, insert as _insert$ } from "est";
const _tmpl$ = _template$("<ul>"),
  _tmpl$2 = _template$("<li>");
const items = ['Item 1', 'Item 2', 'Item 3'];
const element = (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1]);
  _insert$(_nodes[0], () => items.map((item, index) => (() => {
    const _el2 = _tmpl$2();
    const _nodes2 = _mapNodes$(_el2, [1]);
    _insert$(_nodes2[0], () => item);
    return _el2;
  })()));
  return _el;
})();"
`;

exports[`jsx transform > should work with memo and custom comparison 1`] = `
"import { template as _template$, createComponent as _createComponent$, mapNodes as _mapNodes$, insert as _insert$ } from "est";
const _tmpl$ = _template$("<div>Memo:");
const MemoComponent = ({
  value
}) => (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1]);
  _insert$(_nodes[0], () => value);
  return _el;
})();
MemoComponent._memo = true;
MemoComponent._compare = (prev, next) => prev.value === next.value;
const element = _createComponent$(MemoComponent, {
  "value": 42
});"
`;

exports[`jsx transform > should work with memo components 1`] = `
"import { template as _template$, createComponent as _createComponent$, mapNodes as _mapNodes$, insert as _insert$ } from "est";
const _tmpl$ = _template$("<div>Memo:");
const MemoComponent = ({
  value
}) => (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1]);
  _insert$(_nodes[0], () => value);
  return _el;
})();
MemoComponent._memo = true;
const element = _createComponent$(MemoComponent, {
  "value": 42
});"
`;

exports[`jsx transform > should work with multiple contexts 1`] = `
"import { template as _template$, createComponent as _createComponent$ } from "est";
const _tmpl$ = _template$("<div data-theme=\\"dark\\" data-user=\\"John\\">Nested Context Content");
const ThemeContext = {
  Provider: ({
    value,
    children
  }) => children
};
const UserContext = {
  Provider: ({
    value,
    children
  }) => children
};
const element = _createComponent$(ThemeContext.Provider, {
  "value": "dark",
  "children": [_createComponent$(UserContext.Provider, {
    "value": {
      name: 'John'
    },
    "children": [(() => {
      const _el = _tmpl$();
      return _el;
    })()]
  })]
});"
`;

exports[`jsx transform > should work with multiple event handlers 1`] = `
"import { template as _template$, createComponent as _createComponent$, mapNodes as _mapNodes$, addEventListener as _addEventListener$, insert as _insert$ } from "est";
const _tmpl$ = _template$("<div>Multiple Events");
const element = (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1]);
  _addEventListener$(_nodes[0], "click", () => console.log('clicked'));
  _addEventListener$(_nodes[0], "mouseenter", () => console.log('mouse enter'));
  _addEventListener$(_nodes[0], "mouseleave", () => console.log('mouse leave'));
  return _el;
})();"
`;

exports[`jsx transform > should work with nested components and props 1`] = `
"import { template as _template$, createComponent as _createComponent$, mapNodes as _mapNodes$, insert as _insert$ } from "est";
const _tmpl$ = _template$("<div>Name:<!>, Age:"),
  _tmpl$2 = _template$("<div><!>");
const Child = ({
  name,
  age
}) => (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1, 3]);
  _insert$(_nodes[0], () => name, _nodes[1]);
  _insert$(_nodes[0], () => age);
  return _el;
})();
const Parent = () => (() => {
  const _el2 = _tmpl$2();
  const _nodes2 = _mapNodes$(_el2, [1, 2]);
  _insert$(_nodes2[0], () => _createComponent$(Child, {
    "name": "John",
    "age": 25
  }), _nodes2[1]);
  _insert$(_nodes2[0], () => _createComponent$(Child, {
    "name": "Jane",
    "age": 23
  }));
  return _el2;
})();"
`;

exports[`jsx transform > should work with portals 1`] = `
"import { template as _template$, createComponent as _createComponent$, mapNodes as _mapNodes$, setAttr as _setAttr$, insert as _insert$ } from "est";
const _tmpl$ = _template$("<div>"),
  _tmpl$2 = _template$("<div>Modal Content");
const Portal = ({
  children,
  target
}) => {
  return (() => {
    const _el = _tmpl$();
    const _nodes = _mapNodes$(_el, [1]);
    _setAttr$(_nodes[0], "data-portal-target", target);
    _insert$(_nodes[0], () => children);
    return _el;
  })();
};
const element = _createComponent$(Portal, {
  "target": "modal",
  "children": [(() => {
    const _el2 = _tmpl$2();
    return _el2;
  })()]
});"
`;

exports[`jsx transform > should work with portals 2`] = `
"import { template as _template$, createComponent as _createComponent$, mapNodes as _mapNodes$, setAttr as _setAttr$, insert as _insert$ } from "est";
const _tmpl$ = _template$("<div>"),
  _tmpl$2 = _template$("<div>Modal Content");
const Portal = ({
  children,
  target
}) => (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1]);
  _setAttr$(_nodes[0], "data-portal-target", target);
  _insert$(_nodes[0], () => children);
  return _el;
})();
const element = _createComponent$(Portal, {
  "target": "modal",
  "children": [(() => {
    const _el2 = _tmpl$2();
    return _el2;
  })()]
});"
`;

exports[`jsx transform > should work with portals and refs 1`] = `
"import { template as _template$, createComponent as _createComponent$, mapNodes as _mapNodes$, setAttr as _setAttr$, insert as _insert$ } from "est";
const _tmpl$ = _template$("<div>"),
  _tmpl$2 = _template$("<div>Modal Content with Ref");
const Portal = ({
  children,
  target
}, ref) => (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1]);
  _setAttr$(_nodes[0], "ref", ref);
  _setAttr$(_nodes[0], "data-portal-target", target);
  _insert$(_nodes[0], () => children);
  return _el;
})();
const element = _createComponent$(Portal, {
  "target": "modal",
  "ref": React.createRef(),
  "children": [(() => {
    const _el2 = _tmpl$2();
    return _el2;
  })()]
});"
`;

exports[`jsx transform > should work with refs 1`] = `
"import { template as _template$, createComponent as _createComponent$, mapNodes as _mapNodes$, setAttr as _setAttr$, insert as _insert$ } from "est";
const _tmpl$ = _template$("<div>Reference Element");
const myRef = {
  current: null
};
const element = (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1]);
  _setAttr$(_nodes[0], "ref", myRef);
  return _el;
})();"
`;

exports[`jsx transform > should work with refs and ref forwarding 1`] = `
"import { template as _template$, createComponent as _createComponent$, mapNodes as _mapNodes$, setAttr as _setAttr$, insert as _insert$ } from "est";
const _tmpl$ = _template$("<div data-ref>");
const RefComponent = ({
  children
}, ref) => (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1]);
  _setAttr$(_nodes[0], "ref", ref);
  _insert$(_nodes[0], () => children);
  return _el;
})();
const element = _createComponent$(RefComponent, {
  "ref": React.createRef(),
  "children": ["Ref Content"]
});"
`;

exports[`jsx transform > should work with static style transform to inline style 1`] = `
"import { template as _template$, createComponent as _createComponent$ } from "est";
const _tmpl$ = _template$("<div style=\\"color:red;fontSize:16px;\\">Hello, World!");
const element = (() => {
  const _el = _tmpl$();
  return _el;
})();"
`;

exports[`jsx transform > should work with strict mode 1`] = `
"import { template as _template$, createComponent as _createComponent$, mapNodes as _mapNodes$, insert as _insert$ } from "est";
const _tmpl$ = _template$("<div data-strict>"),
  _tmpl$2 = _template$("<div>Strict Mode Content");
const StrictMode = ({
  children
}) => (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1]);
  _insert$(_nodes[0], () => children);
  return _el;
})();
const element = _createComponent$(StrictMode, {
  "children": [(() => {
    const _el2 = _tmpl$2();
    return _el2;
  })()]
});"
`;

exports[`jsx transform > should work with strict mode and error boundary 1`] = `
"import { template as _template$, createComponent as _createComponent$ } from "est";
const _tmpl$ = _template$("<div>Error occurred!"),
  _tmpl$2 = _template$("<div>Strict Mode Protected Content");
const element = _createComponent$(StrictMode, {
  "children": [_createComponent$(ErrorBoundary, {
    "fallback": (() => {
      const _el = _tmpl$();
      return _el;
    })(),
    "children": [(() => {
      const _el2 = _tmpl$2();
      return _el2;
    })()]
  })]
});"
`;

exports[`jsx transform > should work with suspense and dynamic imports 1`] = `
"import { template as _template$, createComponent as _createComponent$, mapNodes as _mapNodes$, insert as _insert$ } from "est";
const _tmpl$ = _template$("<div data-lazy>"),
  _tmpl$2 = _template$("<div>Loading...");
const LazyComponent = ({
  children
}) => (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1]);
  _insert$(_nodes[0], () => children);
  return _el;
})();
LazyComponent._lazy = true;
const element = _createComponent$(Suspense, {
  "fallback": (() => {
    const _el2 = _tmpl$2();
    return _el2;
  })(),
  "children": [_createComponent$(LazyComponent, {
    "children": [import('./Component')]
  })]
});"
`;

exports[`jsx transform > should work with suspense and error boundary combination 1`] = `
"import { template as _template$, createComponent as _createComponent$ } from "est";
const _tmpl$ = _template$("<div>Error occurred!"),
  _tmpl$2 = _template$("<div>Loading..."),
  _tmpl$3 = _template$("<div>Protected and Suspended Content");
const element = _createComponent$(ErrorBoundary, {
  "fallback": (() => {
    const _el = _tmpl$();
    return _el;
  })(),
  "children": [_createComponent$(Suspense, {
    "fallback": (() => {
      const _el2 = _tmpl$2();
      return _el2;
    })(),
    "children": [(() => {
      const _el3 = _tmpl$3();
      return _el3;
    })()]
  })]
});"
`;

exports[`jsx transform > should work with suspense and lazy loading 1`] = `
"import { template as _template$, createComponent as _createComponent$, mapNodes as _mapNodes$, insert as _insert$ } from "est";
const _tmpl$ = _template$("<div data-lazy>"),
  _tmpl$2 = _template$("<div>Loading...");
const LazyComponent = ({
  children
}) => (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1]);
  _insert$(_nodes[0], () => children);
  return _el;
})();
LazyComponent._lazy = true;
const element = _createComponent$(Suspense, {
  "fallback": (() => {
    const _el2 = _tmpl$2();
    return _el2;
  })(),
  "children": [_createComponent$(LazyComponent, {
    "children": ["Lazy Content"]
  })]
});"
`;

exports[`jsx transform > should work with suspense boundaries 1`] = `
"import { template as _template$, createComponent as _createComponent$, mapNodes as _mapNodes$, insert as _insert$ } from "est";
const _tmpl$ = _template$("<div data-suspense><!>"),
  _tmpl$2 = _template$("<div>Loading..."),
  _tmpl$3 = _template$("<div>Content");
const Suspense = ({
  children,
  fallback
}) => (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1, 2]);
  _insert$(_nodes[0], () => children, _nodes[1]);
  _insert$(_nodes[0], () => fallback);
  return _el;
})();
const element = _createComponent$(Suspense, {
  "fallback": (() => {
    const _el2 = _tmpl$2();
    return _el2;
  })(),
  "children": [(() => {
    const _el3 = _tmpl$3();
    return _el3;
  })()]
});"
`;

exports[`jsx transform > transforms JSX element with JSX fragment 1`] = `
"import { template as _template$, Fragment as _Fragment$ } from "est";
const _tmpl$ = _template$("<p>Paragraph 1</p><p>Paragraph 2</p>");
const element = (() => {
  const _el = _tmpl$();
  return _el;
})();"
`;

exports[`jsx transform > transforms JSX element with JSX fragment as children 1`] = `
"import { template as _template$, createComponent as _createComponent$ } from "est";
const _tmpl$ = _template$("<div><p>Paragraph 1</p><p>Paragraph 2</p>");
const element = (() => {
  const _el = _tmpl$();
  return _el;
})();"
`;

exports[`jsx transform > transforms JSX element with SVG tags 1`] = `
"import { template as _template$, createComponent as _createComponent$ } from "est";
const _tmpl$ = _template$("<svg _svg_><svg><circle cx=\\"50\\" cy=\\"50\\" r=\\"40\\" stroke=\\"black\\" stroke-width=\\"3\\" fill=\\"red\\">");
const element = (() => {
  const _el = _tmpl$();
  return _el;
})();"
`;

exports[`jsx transform > transforms JSX element with attributes 1`] = `
"import { template as _template$, createComponent as _createComponent$ } from "est";
const _tmpl$ = _template$("<div id=\\"myId\\" class=\\"myClass\\">Hello, World!");
const element = (() => {
  const _el = _tmpl$();
  return _el;
})();"
`;

exports[`jsx transform > transforms JSX element with boolean attribute 1`] = `
"import { template as _template$, createComponent as _createComponent$ } from "est";
const _tmpl$ = _template$("<input disabled/>");
const element = (() => {
  const _el = _tmpl$();
  return _el;
})();"
`;

exports[`jsx transform > transforms JSX element with children 1`] = `
"import { template as _template$, createComponent as _createComponent$ } from "est";
const _tmpl$ = _template$("<div><p>Paragraph 1</p><p>Paragraph 2</p>");
const element = (() => {
  const _el = _tmpl$();
  return _el;
})();"
`;

exports[`jsx transform > transforms JSX element with class and style attributes 1`] = `
"import { computed as _computed$, template as _template$, createComponent as _createComponent$, mapNodes as _mapNodes$, setClass as _setClass$, setStyle as _setStyle$, insert as _insert$ } from "est";
const _tmpl$ = _template$("<div>Hello, World!");
const hasClass = true;
const style = {
  color: 'red',
  fontSize: '16px'
};
const element = (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1]);
  _setClass$(_nodes[0], _computed$(() => hasClass ? 'myClass' : ''));
  _setStyle$(_nodes[0], style);
  return _el;
})();"
`;

exports[`jsx transform > transforms JSX element with conditional attributes 1`] = `
"import { computed as _computed$, template as _template$, createComponent as _createComponent$, mapNodes as _mapNodes$, setClass as _setClass$, insert as _insert$ } from "est";
const _tmpl$ = _template$("<div>Hello, World!");
const hasClass = true;
const element = (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1]);
  _setClass$(_nodes[0], _computed$(() => hasClass ? 'myClass' : 'otherClass'));
  return _el;
})();"
`;

exports[`jsx transform > transforms JSX element with dynamic expressions 1`] = `
"import { template as _template$, createComponent as _createComponent$, mapNodes as _mapNodes$, insert as _insert$ } from "est";
const _tmpl$ = _template$("<div>Hello,<!>!");
const name = 'John';
const element = (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1, 3]);
  _insert$(_nodes[0], () => name, _nodes[1]);
  return _el;
})();"
`;

exports[`jsx transform > transforms JSX element with function components 1`] = `
"import { createComponent as _createComponent$, template as _template$, mapNodes as _mapNodes$, insert as _insert$ } from "est";
const _tmpl$ = _template$("<div><!>");
const element = (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1, 2]);
  _insert$(_nodes[0], () => _createComponent$(MyComponent, {
    "text": "Component 1"
  }), _nodes[1]);
  _insert$(_nodes[0], () => _createComponent$(MyComponent, {
    "text": "Component 2"
  }));
  return _el;
})();"
`;

exports[`jsx transform > transforms JSX element with nested expressions and children 1`] = `
"import { template as _template$, createComponent as _createComponent$, mapNodes as _mapNodes$, insert as _insert$ } from "est";
const _tmpl$ = _template$("<div><p><!>'s Profile</p><ul></ul>"),
  _tmpl$2 = _template$("<li>Item");
const name = 'John';
const element = (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [2, 3, 5]);
  _insert$(_nodes[0], () => name, _nodes[1]);
  _insert$(_nodes[2], () => Array.from({
    length: 3
  }, (_, i) => (() => {
    const _el2 = _tmpl$2();
    const _nodes2 = _mapNodes$(_el2, [1]);
    _insert$(_nodes2[0], () => i + 1);
    return _el2;
  })()));
  return _el;
})();"
`;

exports[`jsx transform > transforms JSX element with null and undefined attributes 1`] = `
"import { template as _template$, createComponent as _createComponent$, mapNodes as _mapNodes$, setAttr as _setAttr$, setClass as _setClass$, insert as _insert$ } from "est";
const _tmpl$ = _template$("<div>Hello, World!");
const element = (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1]);
  _setAttr$(_nodes[0], "id", null);
  _setClass$(_nodes[0], undefined);
  return _el;
})();"
`;

exports[`jsx transform > transforms JSX element with null and undefined children 1`] = `
"import { template as _template$, createComponent as _createComponent$, mapNodes as _mapNodes$, insert as _insert$ } from "est";
const _tmpl$ = _template$("<div><!><p>Paragraph 1</p><!><!><p>Paragraph 2</p>");
const element = (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1, 2, 5, 6]);
  _insert$(_nodes[0], () => null, _nodes[1]);
  _insert$(_nodes[0], () => undefined, _nodes[2]);
  _insert$(_nodes[0], () => false, _nodes[3]);
  return _el;
})();"
`;

exports[`jsx transform > transforms JSX element with null and undefined in expressions 1`] = `
"import { template as _template$, createComponent as _createComponent$, mapNodes as _mapNodes$, insert as _insert$ } from "est";
const _tmpl$ = _template$("<div><p><!>'s Profile</p><!><p>Paragraph 2</p>");
const name = null;
const element = (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1, 5, 2, 3]);
  _insert$(_nodes[0], () => undefined, _nodes[1]);
  _insert$(_nodes[2], () => name, _nodes[3]);
  return _el;
})();"
`;

exports[`jsx transform > transforms JSX element with self-closing tags 1`] = `
"import { template as _template$, createComponent as _createComponent$ } from "est";
const _tmpl$ = _template$("<div><img src=\\"image.jpg\\" alt=\\"Image 1\\"/><img src=\\"image.jpg\\" alt=\\"Image 2\\"/>");
const element = (() => {
  const _el = _tmpl$();
  return _el;
})();"
`;

exports[`jsx transform > transforms JSX element with spread attributes 1`] = `
"import { template as _template$, createComponent as _createComponent$, mapNodes as _mapNodes$, setAttr as _setAttr$, insert as _insert$ } from "est";
const _tmpl$ = _template$("<div>Hello, World!");
const props = {
  id: 'myId',
  class: 'myClass'
};
const element = (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1]);
  _setAttr$(_nodes[0], "_$spread$", props);
  return _el;
})();"
`;

exports[`jsx transform > transforms JSX element with style attribute 1`] = `
"import { template as _template$, createComponent as _createComponent$, mapNodes as _mapNodes$, setStyle as _setStyle$, insert as _insert$ } from "est";
const _tmpl$ = _template$("<div>Hello, World!");
const style = {
  color: 'red',
  fontSize: '16px'
};
const element = (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1]);
  _setStyle$(_nodes[0], style);
  return _el;
})();"
`;

exports[`jsx transform > transforms simple JSX element 1`] = `
"import { template as _template$, createComponent as _createComponent$ } from "est";
const _tmpl$ = _template$("<div>Hello, World!");
const element = (() => {
  const _el = _tmpl$();
  return _el;
})();"
`;
